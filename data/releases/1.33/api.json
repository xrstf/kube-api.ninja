{
  "version": "1.33.0",
  "release": "1.33",
  "apiGroups": [
    {
      "name": "",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "ComponentStatus",
              "namespaced": false,
              "singular": "componentstatus",
              "plural": "componentstatuses",
              "description": "ComponentStatus (and ComponentStatusList) holds the cluster validation info. Deprecated: This API is deprecated in v1.19+"
            },
            {
              "kind": "ConfigMap",
              "namespaced": true,
              "singular": "configmap",
              "plural": "configmaps",
              "description": "ConfigMap holds configuration data for pods to consume."
            },
            {
              "kind": "Endpoints",
              "namespaced": true,
              "singular": "endpoints",
              "plural": "endpoints",
              "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]\n\nEndpoints is a legacy API and does not contain information about all Service features. Use discoveryv1.EndpointSlice for complete information about Service endpoints.\n\nDeprecated: This API is deprecated in v1.33+. Use discoveryv1.EndpointSlice."
            },
            {
              "kind": "Event",
              "namespaced": true,
              "singular": "event",
              "plural": "events",
              "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
            },
            {
              "kind": "LimitRange",
              "namespaced": true,
              "singular": "limitrange",
              "plural": "limitranges",
              "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
            },
            {
              "kind": "Namespace",
              "namespaced": false,
              "singular": "namespace",
              "plural": "namespaces",
              "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
            },
            {
              "kind": "Node",
              "namespaced": false,
              "singular": "node",
              "plural": "nodes",
              "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
            },
            {
              "kind": "PersistentVolume",
              "namespaced": false,
              "singular": "persistentvolume",
              "plural": "persistentvolumes",
              "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
            },
            {
              "kind": "PersistentVolumeClaim",
              "namespaced": true,
              "singular": "persistentvolumeclaim",
              "plural": "persistentvolumeclaims",
              "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
            },
            {
              "kind": "Pod",
              "namespaced": true,
              "singular": "pod",
              "plural": "pods",
              "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
            },
            {
              "kind": "PodTemplate",
              "namespaced": true,
              "singular": "podtemplate",
              "plural": "podtemplates",
              "description": "PodTemplate describes a template for creating copies of a predefined pod."
            },
            {
              "kind": "ReplicationController",
              "namespaced": true,
              "singular": "replicationcontroller",
              "plural": "replicationcontrollers",
              "description": "ReplicationController represents the configuration of a replication controller."
            },
            {
              "kind": "ResourceQuota",
              "namespaced": true,
              "singular": "resourcequota",
              "plural": "resourcequotas",
              "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
            },
            {
              "kind": "Secret",
              "namespaced": true,
              "singular": "secret",
              "plural": "secrets",
              "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
            },
            {
              "kind": "Service",
              "namespaced": true,
              "singular": "service",
              "plural": "services",
              "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
            },
            {
              "kind": "ServiceAccount",
              "namespaced": true,
              "singular": "serviceaccount",
              "plural": "serviceaccounts",
              "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
            }
          ]
        }
      ]
    },
    {
      "name": "admissionregistration.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "MutatingWebhookConfiguration",
              "namespaced": false,
              "singular": "mutatingwebhookconfiguration",
              "plural": "mutatingwebhookconfigurations",
              "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
            },
            {
              "kind": "ValidatingAdmissionPolicy",
              "namespaced": false,
              "singular": "validatingadmissionpolicy",
              "plural": "validatingadmissionpolicies",
              "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
            },
            {
              "kind": "ValidatingAdmissionPolicyBinding",
              "namespaced": false,
              "singular": "validatingadmissionpolicybinding",
              "plural": "validatingadmissionpolicybindings",
              "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.\n\nFor a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.\n\nThe CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget."
            },
            {
              "kind": "ValidatingWebhookConfiguration",
              "namespaced": false,
              "singular": "validatingwebhookconfiguration",
              "plural": "validatingwebhookconfigurations",
              "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
            }
          ]
        },
        {
          "version": "v1alpha1",
          "resources": [
            {
              "kind": "MutatingAdmissionPolicy",
              "namespaced": false,
              "singular": "mutatingadmissionpolicy",
              "plural": "mutatingadmissionpolicies",
              "description": "MutatingAdmissionPolicy describes the definition of an admission mutation policy that mutates the object coming into admission chain."
            },
            {
              "kind": "MutatingAdmissionPolicyBinding",
              "namespaced": false,
              "singular": "mutatingadmissionpolicybinding",
              "plural": "mutatingadmissionpolicybindings",
              "description": "MutatingAdmissionPolicyBinding binds the MutatingAdmissionPolicy with parametrized resources. MutatingAdmissionPolicyBinding and the optional parameter resource together define how cluster administrators configure policies for clusters.\n\nFor a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding. Each evaluation is constrained by a [runtime cost budget](https://kubernetes.io/docs/reference/using-api/cel/#runtime-cost-budget).\n\nAdding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget."
            }
          ]
        },
        {
          "version": "v1beta1",
          "resources": [
            {
              "kind": "ValidatingAdmissionPolicy",
              "namespaced": false,
              "singular": "validatingadmissionpolicy",
              "plural": "validatingadmissionpolicies",
              "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
            },
            {
              "kind": "ValidatingAdmissionPolicyBinding",
              "namespaced": false,
              "singular": "validatingadmissionpolicybinding",
              "plural": "validatingadmissionpolicybindings",
              "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.\n\nFor a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.\n\nThe CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget."
            }
          ]
        }
      ]
    },
    {
      "name": "apiextensions.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "CustomResourceDefinition",
              "namespaced": false,
              "singular": "customresourcedefinition",
              "plural": "customresourcedefinitions",
              "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format \u003c.spec.name\u003e.\u003c.spec.group\u003e."
            }
          ]
        }
      ]
    },
    {
      "name": "apiregistration.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "APIService",
              "namespaced": false,
              "singular": "apiservice",
              "plural": "apiservices",
              "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
            }
          ]
        }
      ]
    },
    {
      "name": "apps",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "ControllerRevision",
              "namespaced": true,
              "singular": "controllerrevision",
              "plural": "controllerrevisions",
              "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
            },
            {
              "kind": "DaemonSet",
              "namespaced": true,
              "singular": "daemonset",
              "plural": "daemonsets",
              "description": "DaemonSet represents the configuration of a daemon set."
            },
            {
              "kind": "Deployment",
              "namespaced": true,
              "singular": "deployment",
              "plural": "deployments",
              "description": "Deployment enables declarative updates for Pods and ReplicaSets."
            },
            {
              "kind": "ReplicaSet",
              "namespaced": true,
              "singular": "replicaset",
              "plural": "replicasets",
              "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
            },
            {
              "kind": "StatefulSet",
              "namespaced": true,
              "singular": "statefulset",
              "plural": "statefulsets",
              "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
            }
          ]
        }
      ]
    },
    {
      "name": "authentication.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "SelfSubjectReview",
              "namespaced": false,
              "singular": "selfsubjectreview",
              "plural": "selfsubjectreviews",
              "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
            },
            {
              "kind": "TokenReview",
              "namespaced": false,
              "singular": "tokenreview",
              "plural": "tokenreviews",
              "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
            }
          ]
        },
        {
          "version": "v1beta1",
          "resources": [
            {
              "kind": "SelfSubjectReview",
              "namespaced": false,
              "singular": "selfsubjectreview",
              "plural": "selfsubjectreviews",
              "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
            }
          ]
        }
      ]
    },
    {
      "name": "authorization.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "SelfSubjectAccessReview",
              "namespaced": false,
              "singular": "selfsubjectaccessreview",
              "plural": "selfsubjectaccessreviews",
              "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
            },
            {
              "kind": "SelfSubjectRulesReview",
              "namespaced": false,
              "singular": "selfsubjectrulesreview",
              "plural": "selfsubjectrulesreviews",
              "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
            },
            {
              "kind": "SubjectAccessReview",
              "namespaced": false,
              "singular": "subjectaccessreview",
              "plural": "subjectaccessreviews",
              "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
            }
          ]
        }
      ]
    },
    {
      "name": "autoscaling",
      "preferredVersion": "v2",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "HorizontalPodAutoscaler",
              "namespaced": true,
              "singular": "horizontalpodautoscaler",
              "plural": "horizontalpodautoscalers",
              "description": "configuration of a horizontal pod autoscaler."
            }
          ]
        },
        {
          "version": "v2",
          "resources": [
            {
              "kind": "HorizontalPodAutoscaler",
              "namespaced": true,
              "singular": "horizontalpodautoscaler",
              "plural": "horizontalpodautoscalers",
              "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
            }
          ]
        }
      ]
    },
    {
      "name": "batch",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "CronJob",
              "namespaced": true,
              "singular": "cronjob",
              "plural": "cronjobs",
              "description": "CronJob represents the configuration of a single cron job."
            },
            {
              "kind": "Job",
              "namespaced": true,
              "singular": "job",
              "plural": "jobs",
              "description": "Job represents the configuration of a single job."
            }
          ]
        }
      ]
    },
    {
      "name": "certificates.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "CertificateSigningRequest",
              "namespaced": false,
              "singular": "certificatesigningrequest",
              "plural": "certificatesigningrequests",
              "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
            }
          ]
        },
        {
          "version": "v1alpha1",
          "resources": [
            {
              "kind": "ClusterTrustBundle",
              "namespaced": false,
              "singular": "clustertrustbundle",
              "plural": "clustertrustbundles",
              "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
            }
          ]
        }
      ]
    },
    {
      "name": "coordination.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "Lease",
              "namespaced": true,
              "singular": "lease",
              "plural": "leases",
              "description": "Lease defines a lease concept."
            }
          ]
        },
        {
          "version": "v1alpha2",
          "resources": [
            {
              "kind": "LeaseCandidate",
              "namespaced": true,
              "singular": "leasecandidate",
              "plural": "leasecandidates",
              "description": "LeaseCandidate defines a candidate for a Lease object. Candidates are created such that coordinated leader election will pick the best leader from the list of candidates."
            }
          ]
        }
      ]
    },
    {
      "name": "discovery.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "EndpointSlice",
              "namespaced": true,
              "singular": "endpointslice",
              "plural": "endpointslices",
              "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
            }
          ]
        }
      ]
    },
    {
      "name": "events.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "Event",
              "namespaced": true,
              "singular": "event",
              "plural": "events",
              "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
            }
          ]
        }
      ]
    },
    {
      "name": "flowcontrol.apiserver.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "FlowSchema",
              "namespaced": false,
              "singular": "flowschema",
              "plural": "flowschemas",
              "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
            },
            {
              "kind": "PriorityLevelConfiguration",
              "namespaced": false,
              "singular": "prioritylevelconfiguration",
              "plural": "prioritylevelconfigurations",
              "description": "PriorityLevelConfiguration represents the configuration of a priority level."
            }
          ]
        }
      ]
    },
    {
      "name": "internal.apiserver.k8s.io",
      "preferredVersion": "v1alpha1",
      "apiVersions": [
        {
          "version": "v1alpha1",
          "resources": [
            {
              "kind": "StorageVersion",
              "namespaced": false,
              "singular": "storageversion",
              "plural": "storageversions",
              "description": "Storage version of a specific resource."
            }
          ]
        }
      ]
    },
    {
      "name": "networking.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "IPAddress",
              "namespaced": false,
              "singular": "ipaddress",
              "plural": "ipaddresses",
              "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
            },
            {
              "kind": "Ingress",
              "namespaced": true,
              "singular": "ingress",
              "plural": "ingresses",
              "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
            },
            {
              "kind": "IngressClass",
              "namespaced": false,
              "singular": "ingressclass",
              "plural": "ingressclasses",
              "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
            },
            {
              "kind": "NetworkPolicy",
              "namespaced": true,
              "singular": "networkpolicy",
              "plural": "networkpolicies",
              "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
            },
            {
              "kind": "ServiceCIDR",
              "namespaced": false,
              "singular": "servicecidr",
              "plural": "servicecidrs",
              "description": "ServiceCIDR defines a range of IP addresses using CIDR format (e.g. 192.168.0.0/24 or 2001:db2::/64). This range is used to allocate ClusterIPs to Service objects."
            }
          ]
        },
        {
          "version": "v1beta1",
          "resources": [
            {
              "kind": "IPAddress",
              "namespaced": false,
              "singular": "ipaddress",
              "plural": "ipaddresses",
              "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
            },
            {
              "kind": "ServiceCIDR",
              "namespaced": false,
              "singular": "servicecidr",
              "plural": "servicecidrs",
              "description": "ServiceCIDR defines a range of IP addresses using CIDR format (e.g. 192.168.0.0/24 or 2001:db2::/64). This range is used to allocate ClusterIPs to Service objects."
            }
          ]
        }
      ]
    },
    {
      "name": "node.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "RuntimeClass",
              "namespaced": false,
              "singular": "runtimeclass",
              "plural": "runtimeclasses",
              "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
            }
          ]
        }
      ]
    },
    {
      "name": "policy",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "PodDisruptionBudget",
              "namespaced": true,
              "singular": "poddisruptionbudget",
              "plural": "poddisruptionbudgets",
              "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
            }
          ]
        }
      ]
    },
    {
      "name": "rbac.authorization.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "ClusterRole",
              "namespaced": false,
              "singular": "clusterrole",
              "plural": "clusterroles",
              "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
            },
            {
              "kind": "ClusterRoleBinding",
              "namespaced": false,
              "singular": "clusterrolebinding",
              "plural": "clusterrolebindings",
              "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
            },
            {
              "kind": "Role",
              "namespaced": true,
              "singular": "role",
              "plural": "roles",
              "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
            },
            {
              "kind": "RoleBinding",
              "namespaced": true,
              "singular": "rolebinding",
              "plural": "rolebindings",
              "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
            }
          ]
        }
      ]
    },
    {
      "name": "resource.k8s.io",
      "preferredVersion": "v1beta1",
      "apiVersions": [
        {
          "version": "v1alpha3",
          "resources": [
            {
              "kind": "DeviceClass",
              "namespaced": false,
              "singular": "deviceclass",
              "plural": "deviceclasses",
              "description": "DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            },
            {
              "kind": "ResourceClaim",
              "namespaced": true,
              "singular": "resourceclaim",
              "plural": "resourceclaims",
              "description": "ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            },
            {
              "kind": "ResourceClaimTemplate",
              "namespaced": true,
              "singular": "resourceclaimtemplate",
              "plural": "resourceclaimtemplates",
              "description": "ResourceClaimTemplate is used to produce ResourceClaim objects.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            },
            {
              "kind": "ResourceSlice",
              "namespaced": false,
              "singular": "resourceslice",
              "plural": "resourceslices",
              "description": "ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.\n\nAt the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple \u003cdriver name\u003e, \u003cpool name\u003e, \u003cdevice name\u003e.\n\nWhenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.\n\nWhen allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.\n\nFor resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            }
          ]
        },
        {
          "version": "v1beta1",
          "resources": [
            {
              "kind": "DeviceClass",
              "namespaced": false,
              "singular": "deviceclass",
              "plural": "deviceclasses",
              "description": "DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            },
            {
              "kind": "ResourceClaim",
              "namespaced": true,
              "singular": "resourceclaim",
              "plural": "resourceclaims",
              "description": "ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            },
            {
              "kind": "ResourceClaimTemplate",
              "namespaced": true,
              "singular": "resourceclaimtemplate",
              "plural": "resourceclaimtemplates",
              "description": "ResourceClaimTemplate is used to produce ResourceClaim objects.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            },
            {
              "kind": "ResourceSlice",
              "namespaced": false,
              "singular": "resourceslice",
              "plural": "resourceslices",
              "description": "ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.\n\nAt the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple \u003cdriver name\u003e, \u003cpool name\u003e, \u003cdevice name\u003e.\n\nWhenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.\n\nWhen allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.\n\nFor resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
            }
          ]
        }
      ]
    },
    {
      "name": "scheduling.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "PriorityClass",
              "namespaced": false,
              "singular": "priorityclass",
              "plural": "priorityclasses",
              "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
            }
          ]
        }
      ]
    },
    {
      "name": "storage.k8s.io",
      "preferredVersion": "v1",
      "apiVersions": [
        {
          "version": "v1",
          "resources": [
            {
              "kind": "CSIDriver",
              "namespaced": false,
              "singular": "csidriver",
              "plural": "csidrivers",
              "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
            },
            {
              "kind": "CSINode",
              "namespaced": false,
              "singular": "csinode",
              "plural": "csinodes",
              "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
            },
            {
              "kind": "CSIStorageCapacity",
              "namespaced": true,
              "singular": "csistoragecapacity",
              "plural": "csistoragecapacities",
              "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
            },
            {
              "kind": "StorageClass",
              "namespaced": false,
              "singular": "storageclass",
              "plural": "storageclasses",
              "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
            },
            {
              "kind": "VolumeAttachment",
              "namespaced": false,
              "singular": "volumeattachment",
              "plural": "volumeattachments",
              "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
            }
          ]
        },
        {
          "version": "v1alpha1",
          "resources": [
            {
              "kind": "VolumeAttributesClass",
              "namespaced": false,
              "singular": "volumeattributesclass",
              "plural": "volumeattributesclasses",
              "description": "VolumeAttributesClass represents a specification of mutable volume attributes defined by the CSI driver. The class can be specified during dynamic provisioning of PersistentVolumeClaims, and changed in the PersistentVolumeClaim spec after provisioning."
            }
          ]
        },
        {
          "version": "v1beta1",
          "resources": [
            {
              "kind": "VolumeAttributesClass",
              "namespaced": false,
              "singular": "volumeattributesclass",
              "plural": "volumeattributesclasses",
              "description": "VolumeAttributesClass represents a specification of mutable volume attributes defined by the CSI driver. The class can be specified during dynamic provisioning of PersistentVolumeClaims, and changed in the PersistentVolumeClaim spec after provisioning."
            }
          ]
        }
      ]
    },
    {
      "name": "storagemigration.k8s.io",
      "preferredVersion": "v1alpha1",
      "apiVersions": [
        {
          "version": "v1alpha1",
          "resources": [
            {
              "kind": "StorageVersionMigration",
              "namespaced": false,
              "singular": "storageversionmigration",
              "plural": "storageversionmigrations",
              "description": "StorageVersionMigration represents a migration of stored data to the latest storage version."
            }
          ]
        }
      ]
    }
  ]
}
